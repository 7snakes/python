# 1. Реализовать класс Matrix (матрица). Обеспечить перегрузку конструктора класса (метод __init__()), который должен принимать данные (список списков) для формирования матрицы.
#    Подсказка: матрица — система некоторых математических величин, расположенных в виде прямоугольной схемы.
#    Примеры матриц вы найдете в методичке.
#    Следующий шаг — реализовать перегрузку метода __str__() для вывода матрицы в привычном виде.
#    Далее реализовать перегрузку метода __add__() для реализации операции сложения двух объектов класса Matrix (двух матриц). Результатом сложения должна быть новая матрица.
#    Подсказка: сложение элементов матриц выполнять поэлементно — первый элемент первой строки первой матрицы складываем с первым элементом первой строки второй матрицы и т.д.
class Matrix:
    list_of_list = [[]]

    def __init__(self, list_of_list):
        self.list_of_list = list_of_list

    def __str__(self):
        result_str_matrix = ""
        for line in self.list_of_list:
            result_str_matrix = result_str_matrix + "\n"
            for k in line:
                result_str_matrix = result_str_matrix + str(k) + " "
        return result_str_matrix

    def __add__(self, other):
        for x in range(len(other.list_of_list)):
            for y in range(len(other.list_of_list[x])):
                other.list_of_list[x][y] = self.list_of_list[x][y] * other.list_of_list[x][y]
        return other


print(Matrix([[31, 22], [37, 43], [51, 86]]))
print(Matrix([[3, 5, 32], [2, 4, 6], [-1, 64, -8]]))
print(Matrix([[3, 5, 8, 3], [8, 3, 7, 1]]))
print(Matrix([[8, 7, 6, 5], [4, 3, 2, 1]]) + Matrix([[1, 2, 3, 4], [5, 6, 7, 8]]))

# 2. Реализовать проект расчета суммарного расхода ткани на производство одежды. Основная сущность (класс) этого проекта — одежда, которая может иметь определенное название.
# К типам одежды в этом проекте относятся пальто и костюм. У этих типов одежды существуют параметры: размер (для пальто) и рост (для костюма). Это могут быть обычные числа: V и H, соответственно.
# Для определения расхода ткани по каждому типу одежды использовать формулы: для пальто (V/6.5 + 0.5), для костюма (2 * H + 0.3). Проверить работу этих методов на реальных данных.
# Реализовать общий подсчет расхода ткани. Проверить на практике полученные на этом уроке знания: реализовать абстрактные классы для основных классов проекта, проверить на практике работу декоратора @property.

from abc import abstractmethod


class AbstractClothes:

    @abstractmethod
    def calc_amount_of_cloth(self):
        pass


class Clothes(AbstractClothes):
    v = 0
    h = 0

    def __init__(self, v, h):
        self.v = v
        self.h = h

    def calc_amount_of_cloth(self):
        pass


class Coat(Clothes):

    @property
    def calc_amount_of_cloth(self):
        return self.v / 6.5 + 0.5


class Costume(Clothes):

    @property
    def calc_amount_of_cloth(self):
        return self.h * 2 + 0.3


print(Coat(1, 2).calc_amount_of_cloth)
print(Costume(1, 2).calc_amount_of_cloth)


# 3. Реализовать программу работы с органическими клетками. Необходимо создать класс Клетка. В его конструкторе инициализировать параметр, соответствующий количеству клеток (целое число).
# В классе должны быть реализованы методы перегрузки арифметических операторов: сложение (__add__()), вычитание (__sub__()), умножение (__mul__()), деление (__truediv__()).
# Данные методы должны применяться только к клеткам и выполнять увеличение, уменьшение, умножение и обычное (не целочисленное) деление клеток, соответственно. В методе деления должно осуществляться округление значения до целого числа.
# Сложение. Объединение двух клеток. При этом число ячеек общей клетки должно равняться сумме ячеек исходных двух клеток.
# Вычитание. Участвуют две клетки. Операцию необходимо выполнять только если разность количества ячеек двух клеток больше нуля, иначе выводить соответствующее сообщение.
# Умножение. Создается общая клетка из двух. Число ячеек общей клетки определяется как произведение количества ячеек этих двух клеток.
# Деление. Создается общая клетка из двух. Число ячеек общей клетки определяется как целочисленное деление количества ячеек этих двух клеток.
# В классе необходимо реализовать метод make_order(), принимающий экземпляр класса и количество ячеек в ряду. Данный метод позволяет организовать ячейки по рядам.
# Метод должен возвращать строку вида *****\n*****\n*****..., где количество ячеек между \n равно переданному аргументу. Если ячеек на формирование ряда не хватает, то в последний ряд записываются все оставшиеся.
# Например, количество ячеек клетки равняется 12, количество ячеек в ряду — 5. Тогда метод make_order() вернет строку: *****\n*****\n**.
# Или, количество ячеек клетки равняется 15, количество ячеек в ряду — 5. Тогда метод make_order() вернет строку: *****\n*****\n*****.
# Подсказка: подробный список операторов для перегрузки доступен по ссылке.

class Cell:
    amount_of_cells = 0

    def __init__(self, amount_of_cells):
        self.amount_of_cells = amount_of_cells

    def __add__(self, other):
        return Cell(self.amount_of_cells + other.amount_of_cells)

    def __sub__(self, other):
        if self.amount_of_cells > other.amount_of_cells:
            return Cell(self.amount_of_cells - other.amount_of_cells)

    def __mul__(self, other):
        return Cell(self.amount_of_cells * other.amount_of_cells)

    def __truediv__(self, other):
        return Cell(self.amount_of_cells // other.amount_of_cells)

    def make_order(self, rows):
        rows, tail = self.amount_of_cells // rows, self.amount_of_cells % rows
        print(rows, tail)
        return '\n'.join(['*' * rows] * rows + (['*' * tail] if tail else []))

    def __str__(self):
        return "Клетка состоит из {} ячеек".format(self.amount_of_cells)


c1 = Cell(14)
print(c1)
c2 = Cell(12)
print(c2)

print(c1 + c2)
print(c1 - c2)
print(c2 - c1)
print(c2 - c2)
print(c1 * c2)
print(c1 / c2)
print((c1 * c2).make_order(21))
